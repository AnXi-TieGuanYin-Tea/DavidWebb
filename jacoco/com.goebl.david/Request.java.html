<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="de"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>Request.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">DavidWebb</a> &gt; <a href="index.source.html" class="el_package">com.goebl.david</a> &gt; <span class="el_source">Request.java</span></div><h1>Request.java</h1><pre class="source lang-java linenums">package com.goebl.david;

import org.json.JSONArray;
import org.json.JSONObject;

import java.io.File;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.Collection;
import java.util.LinkedHashMap;
import java.util.Map;

/**
 * Builder for an HTTP request.
 * &lt;br&gt;
 * You can some &quot;real-life&quot; usage examples at
 * &lt;a href=&quot;https://github.com/hgoebl/DavidWebb&quot;&gt;github.com/hgoebl/DavidWebb&lt;/a&gt;.
 * &lt;br&gt;
 *
 * @author hgoebl
 */
public class Request {
<span class="pc" id="L23">    public enum Method {</span>
<span class="fc" id="L24">        GET, POST, PUT, DELETE</span>
    }

    private final Webb webb;
    final Method method;
    final String uri;

    Map&lt;String, Object&gt; params;
    boolean multipleValues;
    Map&lt;String, Object&gt; headers;
    Object payload;
    boolean streamPayload;
    boolean useCaches;
    Integer connectTimeout;
    Integer readTimeout;
    Long ifModifiedSince;
    Boolean followRedirects;
    boolean ensureSuccess;
    boolean compress;
    int retryCount;
    boolean waitExponential;

<span class="fc" id="L46">    Request(Webb webb, Method method, String uri) {</span>
<span class="fc" id="L47">        this.webb = webb;</span>
<span class="fc" id="L48">        this.method = method;</span>
<span class="fc" id="L49">        this.uri = uri;</span>
<span class="fc" id="L50">        this.followRedirects = webb.followRedirects;</span>
<span class="fc" id="L51">    }</span>

    /**
     * Turn on a mode where one parameter key can have multiple values.
     * &lt;br&gt;
     * Example: &lt;code&gt;order.php?fruit=orange&amp;amp;fruit=apple&amp;amp;fruit=banana&lt;/code&gt;
     * &lt;br&gt;
     * This is only necessary when you want to call {@link #param(String, Object)} multiple
     * times with the same parameter name and this should lead to having multiple values.
     * If you call {@link #param(String, Iterable)} or already provide an Array as value parameter,
     * you don't have to call this method and it should work as expected.
     *
     * @return &lt;code&gt;this&lt;/code&gt; for method chaining (fluent API)
     * @since 1.3.0
     */
    public Request multipleValues() {
<span class="fc" id="L67">        multipleValues = true;</span>
<span class="fc" id="L68">        return this;</span>
    }

    /**
     * Set (or overwrite) a parameter.
     * &lt;br&gt;
     * The parameter will be used to create a query string for GET-requests and as the body for POST-requests
     * with MIME-type &lt;code&gt;application/x-www-form-urlencoded&lt;/code&gt;.
     * &lt;br&gt;
     * Please see {@link #multipleValues()} if you have to deal with parameters carrying multiple values.
     * &lt;br&gt;
     * Handling of multi-valued parameters exists since version 1.3.0
     *
     * @param name the name of the parameter (it's better to use only contain ASCII characters)
     * @param value the value of the parameter; &lt;code&gt;null&lt;/code&gt; will be converted to empty string,
     *              Arrays of Objects are expanded to multiple valued parameters, for all other
     *              objects to &lt;code&gt;toString()&lt;/code&gt; method converts it to String
     * @return &lt;code&gt;this&lt;/code&gt; for method chaining (fluent API)
     */
    public Request param(String name, Object value) {
<span class="fc bfc" id="L88" title="All 2 branches covered.">        if (params == null) {</span>
<span class="fc" id="L89">            params = new LinkedHashMap&lt;String, Object&gt;();</span>
        }
<span class="fc bfc" id="L91" title="All 2 branches covered.">        if (multipleValues) {</span>
<span class="fc" id="L92">            Object currentValue = params.get(name);</span>
<span class="fc bfc" id="L93" title="All 2 branches covered.">            if (currentValue != null) {</span>
<span class="fc bfc" id="L94" title="All 2 branches covered.">                if (currentValue instanceof Collection) {</span>
<span class="fc" id="L95">                    Collection&lt;Object&gt; values = (Collection) currentValue;</span>
<span class="fc" id="L96">                    values.add(value);</span>
<span class="fc" id="L97">                } else {</span>
                    // upgrade single value to set of values
<span class="fc" id="L99">                    Collection&lt;Object&gt; values = new ArrayList&lt;Object&gt;();</span>
<span class="fc" id="L100">                    values.add(currentValue);</span>
<span class="fc" id="L101">                    values.add(value);</span>
<span class="fc" id="L102">                    params.put(name, values);</span>
                }
<span class="fc" id="L104">                return this;</span>
            }
        }
<span class="fc" id="L107">        params.put(name, value);</span>
<span class="fc" id="L108">        return this;</span>
    }

    /**
     * Set (or overwrite) a parameter with multiple values.
     * &lt;br&gt;
     * The parameter will be used to create a query string for GET-requests and as the body for POST-requests
     * with MIME-type &lt;code&gt;application/x-www-form-urlencoded&lt;/code&gt;.
     * &lt;br&gt;
     * If you use this method, you don't have to call {@link #multipleValues()}, but you should not mix
     * using {@link #param(String, Object)} and this method for the same parameter name as this might cause
     * unexpected behaviour or exceptions.
     *
     * @param name the name of the parameter (it's better to use only contain ASCII characters)
     * @param values the values of the parameter; will be expanded to multiple valued parameters.
     * @return &lt;code&gt;this&lt;/code&gt; for method chaining (fluent API)
     * @since 1.3.0
     */
    public Request param(String name, Iterable&lt;Object&gt; values) {
<span class="pc bpc" id="L127" title="1 of 2 branches missed.">        if (params == null) {</span>
<span class="nc" id="L128">            params = new LinkedHashMap&lt;String, Object&gt;();</span>
        }
<span class="fc" id="L130">        params.put(name, values);</span>
<span class="fc" id="L131">        return this;</span>
    }

    /**
     * Set (or overwrite) many parameters via a map.
     * &lt;br&gt;
     * @param valueByName a Map of name-value pairs,&lt;br&gt;
     *  the name of the parameter (it's better to use only contain ASCII characters)&lt;br&gt;
     *  the value of the parameter; &lt;code&gt;null&lt;/code&gt; will be converted to empty string, for all other
     *              objects to &lt;code&gt;toString()&lt;/code&gt; method converts it to String
     * @return &lt;code&gt;this&lt;/code&gt; for method chaining (fluent API)
     */
    public Request params(Map&lt;String, Object&gt; valueByName) {
<span class="pc bpc" id="L144" title="1 of 2 branches missed.">        if (params == null) {</span>
<span class="fc" id="L145">            params = new LinkedHashMap&lt;String, Object&gt;();</span>
        }
<span class="fc" id="L147">        params.putAll(valueByName);</span>
<span class="fc" id="L148">        return this;</span>
    }

    /**
     * Get the URI of this request.
     *
     * @return URI
     */
    public String getUri() {
<span class="fc" id="L157">        return uri;</span>
    }

    /**
     * Set (or overwrite) a HTTP header value.
     * &lt;br&gt;
     * Setting a header this way has the highest precedence and overrides a header value set on a {@link Webb}
     * instance ({@link Webb#setDefaultHeader(String, Object)}) or a global header
     * ({@link Webb#setGlobalHeader(String, Object)}).
     * &lt;br&gt;
     * Using &lt;code&gt;null&lt;/code&gt; or empty String is not allowed for name and value.
     *
     * @param name name of the header (HTTP-headers are not case-sensitive, but if you want to override your own
     *             headers, you have to use identical strings for the name. There are some frequently used header
     *             names as constants in {@link Webb}, see HDR_xxx.
     * @param value the value for the header. Following types are supported, all other types use &lt;code&gt;toString&lt;/code&gt;
     *              of the given object:
     *              &lt;ul&gt;
     *              &lt;li&gt;{@link java.util.Date} is converted to RFC1123 compliant String&lt;/li&gt;
     *              &lt;li&gt;{@link java.util.Calendar} is converted to RFC1123 compliant String&lt;/li&gt;
     *              &lt;/ul&gt;
     * @return &lt;code&gt;this&lt;/code&gt; for method chaining (fluent API)
     */
    public Request header(String name, Object value) {
<span class="fc bfc" id="L181" title="All 2 branches covered.">        if (headers == null) {</span>
<span class="fc" id="L182">            headers = new LinkedHashMap&lt;String, Object&gt;();</span>
        }
<span class="fc" id="L184">        headers.put(name, value);</span>
<span class="fc" id="L185">        return this;</span>
    }

    /**
     * Set the payload for the request.
     * &lt;br&gt;
     * Using this method together with {@link #param(String, Object)} has the effect of &lt;code&gt;body&lt;/code&gt; being
     * ignored without notice. The method can be called more than once: the value will be stored and converted
     * to bytes later.
     * &lt;br&gt;
     * Following types are supported for the body:
     * &lt;ul&gt;
     *     &lt;li&gt;
     *         &lt;code&gt;null&lt;/code&gt; clears the body
     *     &lt;/li&gt;
     *     &lt;li&gt;
     *         {@link org.json.JSONObject}, HTTP header 'Content-Type' will be set to JSON, if not set
     *     &lt;/li&gt;
     *     &lt;li&gt;
     *         {@link org.json.JSONArray}, HTTP header 'Content-Type' will be set to JSON, if not set
     *     &lt;/li&gt;
     *     &lt;li&gt;
     *         {@link java.lang.String}, HTTP header 'Content-Type' will be set to TEXT, if not set;
     *         Text will be converted to UTF-8 bytes.
     *     &lt;/li&gt;
     *     &lt;li&gt;
     *         &lt;code&gt;byte[]&lt;/code&gt; the easiest way for DavidWebb - it's just passed through.
     *         HTTP header 'Content-Type' will be set to BINARY, if not set.
     *     &lt;/li&gt;
     *     &lt;li&gt;
     *         {@link java.io.File}, HTTP header 'Content-Type' will be set to BINARY, if not set;
     *         The file gets streamed to the web-server and 'Content-Length' will be set to the number
     *         of bytes of the file. There is absolutely no conversion done. So if you want to upload
     *         e.g. a text-file and convert it to another encoding than stored on disk, you have to do
     *         it by yourself.
     *     &lt;/li&gt;
     *     &lt;li&gt;
     *         {@link java.io.InputStream}, HTTP header 'Content-Type' will be set to BINARY, if not set;
     *         Similar to &lt;code&gt;File&lt;/code&gt;. Content-Length cannot be set (which has some drawbacks compared
     *         to knowing the size of the body in advance).&lt;br&gt;
     *         &lt;strong&gt;You have to care for closing the stream!&lt;/strong&gt;
     *     &lt;/li&gt;
     * &lt;/ul&gt;
     *
     * @param body the payload
     * @return &lt;code&gt;this&lt;/code&gt; for method chaining (fluent API)
     */
    public Request body(Object body) {
<span class="fc bfc" id="L233" title="All 4 branches covered.">        if (method == Method.GET || method == Method.DELETE) {</span>
<span class="fc" id="L234">            throw new IllegalStateException(&quot;body not allowed for request method &quot; + method);</span>
        }
<span class="fc" id="L236">        this.payload = body;</span>
<span class="fc bfc" id="L237" title="All 4 branches covered.">        this.streamPayload = body instanceof File || body instanceof InputStream;</span>
<span class="fc" id="L238">        return this;</span>
    }

    /**
     * Enable compression for uploaded data.&lt;br&gt;
     * &lt;br&gt;
     * Before you enable compression, you should find out, whether the web server you are talking to
     * supports this. As compression has not to be implemented for HTTP and standard RFC2616 had only
     * compression for downloaded resources in mind, in special cases it makes absolutely sense to
     * compress the posted data.&lt;br&gt;
     * Your web application should inspect the 'Content-Encoding' header and implement the compression
     * token provided by this client. By now only 'gzip' encoding token is used. If you need 'deflate'
     * create an issue.
     *
     * @return &lt;code&gt;this&lt;/code&gt; for method chaining (fluent API)
     */
    public Request compress() {
<span class="fc" id="L255">        compress = true;</span>
<span class="fc" id="L256">        return this;</span>
    }

    /**
     * See &lt;a href=&quot;http://docs.oracle.com/javase/7/docs/api/java/net/URLConnection.html#useCaches&quot;&gt;
     *     URLConnection.useCaches&lt;/a&gt;
     * &lt;br&gt;
     * If you don't want your requests delivered from a cache, you don't have to call this method,
     * because &lt;code&gt;false&lt;/code&gt; is the default.
     *
     * @param useCaches If &lt;code&gt;true&lt;/code&gt;, the protocol is allowed to use caching whenever it can.
     * @return &lt;code&gt;this&lt;/code&gt; for method chaining (fluent API)
     */
    public Request useCaches(boolean useCaches) {
<span class="fc" id="L270">        this.useCaches = useCaches;</span>
<span class="fc" id="L271">        return this;</span>
    }

    /**
     * See &lt;a href=&quot;http://docs.oracle.com/javase/7/docs/api/java/net/URLConnection.html#setIfModifiedSince(long)&quot;&gt;
     *     URLConnection.setIfModifiedSince()&lt;/a&gt;
     * @param ifModifiedSince A nonzero value gives a time as the number of milliseconds since January 1, 1970, GMT.
     *                        The object is fetched only if it has been modified more recently than that time.
     * @return &lt;code&gt;this&lt;/code&gt; for method chaining (fluent API)
     */
    public Request ifModifiedSince(long ifModifiedSince) {
<span class="fc" id="L282">        this.ifModifiedSince = ifModifiedSince;</span>
<span class="fc" id="L283">        return this;</span>
    }

    /**
     * See &lt;a href=&quot;http://docs.oracle.com/javase/7/docs/api/java/net/URLConnection.html#setConnectTimeout(int)&quot;&gt;
     *     URLConnection.setConnectTimeout&lt;/a&gt;
     * @param connectTimeout sets a specified timeout value, in milliseconds. &lt;code&gt;0&lt;/code&gt; means infinite timeout.
     * @return &lt;code&gt;this&lt;/code&gt; for method chaining (fluent API)
     */
    public Request connectTimeout(int connectTimeout) {
<span class="fc" id="L293">        this.connectTimeout = connectTimeout;</span>
<span class="fc" id="L294">        return this;</span>
    }

    /**
     * See &lt;a href=&quot;http://docs.oracle.com/javase/7/docs/api/java/net/URLConnection.html#setReadTimeout(int)&quot;&gt;
     *     &lt;/a&gt;
     * @param readTimeout Sets the read timeout to a specified timeout, in milliseconds.
     *                    &lt;code&gt;0&lt;/code&gt; means infinite timeout.
     * @return &lt;code&gt;this&lt;/code&gt; for method chaining (fluent API)
     */
    public Request readTimeout(int readTimeout) {
<span class="fc" id="L305">        this.readTimeout = readTimeout;</span>
<span class="fc" id="L306">        return this;</span>
    }

    /**
     * See &lt;a href=&quot;http://docs.oracle.com/javase/7/docs/api/java/net/HttpURLConnection.html#setInstanceFollowRedirects(boolean)&quot;&gt;
     *     &lt;/a&gt;.
     * &lt;br&gt;
     * Use this method to set the behaviour for this single request when receiving redirect responses.
     * If you want to change the behaviour for all your requests, call {@link Webb#setFollowRedirects(boolean)}.
     * @param auto &lt;code&gt;true&lt;/code&gt; to automatically follow redirects (HTTP status code 3xx).
     *             Default value comes from HttpURLConnection and should be &lt;code&gt;true&lt;/code&gt;.
     * @return &lt;code&gt;this&lt;/code&gt; for method chaining (fluent API)
     */
    public Request followRedirects(boolean auto) {
<span class="fc" id="L320">        this.followRedirects = auto;</span>
<span class="fc" id="L321">        return this;</span>
    }

    /**
     * By calling this method, the HTTP status code is checked and a &lt;code&gt;WebbException&lt;/code&gt; is thrown if
     * the status code is not something like 2xx.&lt;br&gt;
     * &lt;br&gt;
     * Be careful! If you request resources e.g. with {@link #ifModifiedSince(long)}, an exception will also be
     * thrown in the positive case of &lt;code&gt;304 Not Modified&lt;/code&gt;.
     *
     * @return &lt;code&gt;this&lt;/code&gt; for method chaining (fluent API)
     */
    public Request ensureSuccess() {
<span class="fc" id="L334">        this.ensureSuccess = true;</span>
<span class="fc" id="L335">        return this;</span>
    }

    /**
     * Set the number of retries after the first request failed.
     * &lt;br&gt;
     * When `waitExponential` is set, then there will be {@link Thread#sleep(long)} between
     * the retries. If the thread is interrupted, there will be an `InterruptedException`
     * in the thrown `WebbException`. You can check this with {@link WebbException#getCause()}.
     * The `interrupted` flag will be set to true in this case.
     *
     * @param retryCount This parameter holds the number of retries that will be made AFTER the
     *                   initial send in the event of a error. If an error occurs on the last
     *                   attempt an exception will be raised.&lt;br&gt;
     *                   Values &amp;gt; 10 are ignored (we're not gatling)
     * @param waitExponential sleep during retry attempts (exponential backoff).
     *                        For retry-counts more than 3, &lt;tt&gt;true&lt;/tt&gt; is mandatory.
     * @return &lt;code&gt;this&lt;/code&gt; for method chaining (fluent API)
     */
    public Request retry(int retryCount, boolean waitExponential) {
<span class="pc bpc" id="L355" title="1 of 2 branches missed.">        if (retryCount &lt; 0) {</span>
<span class="nc" id="L356">            retryCount = 0;</span>
        }
<span class="pc bpc" id="L358" title="1 of 2 branches missed.">        if (retryCount &gt; 10) {</span>
<span class="nc" id="L359">            retryCount = 10;</span>
        }
<span class="pc bpc" id="L361" title="1 of 4 branches missed.">        if (retryCount &gt; 3 &amp;&amp; !waitExponential) {</span>
<span class="fc" id="L362">            throw new IllegalArgumentException(&quot;retries &gt; 3 only valid with wait&quot;);</span>
        }
<span class="fc" id="L364">        this.retryCount = retryCount;</span>
<span class="fc" id="L365">        this.waitExponential = waitExponential;</span>
<span class="fc" id="L366">        return this;</span>
    }

    /**
     * Execute the request and expect the result to be convertible to &lt;code&gt;String&lt;/code&gt;.
     * @return the created &lt;code&gt;Response&lt;/code&gt; object carrying the payload from the server as &lt;code&gt;String&lt;/code&gt;
     */
    public Response&lt;String&gt; asString() {
<span class="fc" id="L374">        return webb.execute(this, String.class);</span>
    }

    /**
     * Execute the request and expect the result to be convertible to &lt;code&gt;JSONObject&lt;/code&gt;.
     * @return the created &lt;code&gt;Response&lt;/code&gt; object carrying the payload from the server as &lt;code&gt;JSONObject&lt;/code&gt;
     */
    public Response&lt;JSONObject&gt; asJsonObject() {
<span class="fc" id="L382">        return webb.execute(this, JSONObject.class);</span>
    }

    /**
     * Execute the request and expect the result to be convertible to &lt;code&gt;JSONArray&lt;/code&gt;.
     * @return the created &lt;code&gt;Response&lt;/code&gt; object carrying the payload from the server as &lt;code&gt;JSONArray&lt;/code&gt;
     */
    public Response&lt;JSONArray&gt; asJsonArray() {
<span class="fc" id="L390">        return webb.execute(this, JSONArray.class);</span>
    }

    /**
     * Execute the request and expect the result to be convertible to &lt;code&gt;byte[]&lt;/code&gt;.
     * @return the created &lt;code&gt;Response&lt;/code&gt; object carrying the payload from the server as &lt;code&gt;byte[]&lt;/code&gt;
     */
    public Response&lt;byte[]&gt; asBytes() {
<span class="fc" id="L398">        return (Response&lt;byte[]&gt;) webb.execute(this, Const.BYTE_ARRAY_CLASS);</span>
    }

    /**
     * Execute the request and expect the result to be convertible to &lt;code&gt;InputStream&lt;/code&gt;.
     * @return the created &lt;code&gt;Response&lt;/code&gt; object carrying the payload from the server as &lt;code&gt;InputStream&lt;/code&gt;
     */
    public Response&lt;InputStream&gt; asStream() {
<span class="fc" id="L406">        return webb.execute(this, InputStream.class);</span>
    }

    /**
     * Execute the request and expect no result payload (only status-code and headers).
     * @return the created &lt;code&gt;Response&lt;/code&gt; object where no payload is expected or simply will be ignored.
     */
    public Response&lt;Void&gt; asVoid() {
<span class="fc" id="L414">        return webb.execute(this, Void.class);</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.0.201403182114</span></div></body></html>